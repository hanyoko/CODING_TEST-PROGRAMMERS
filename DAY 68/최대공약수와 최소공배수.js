//나의 풀이
function solution(n, m) {
    const gcd =(a, b) => a % b === 0 ? b : gcd(b, a % b); //최대공약수
    const lcm = (a, b) => a * b / gcd(a, b); // 최소 공배수
    return [gcd(n, m), lcm(n, m)]
}

//최대 공약수 : 두 수 A와 B의 공통된 약수 중에 가장 큰 정수
//최소 공배수 : 두 수 A와 B의 공통된 약수 중에 가장 작은 정수

//3의 약수  → 1, 2, 3
//12의 약수 → 1, 2, 3, 4, 6, 12 

//3, 12의 최대 공약수  → 3

//6의 배수  → 3 , 6, 9 ,12, 15  ...
//12의 배수 → 12, 24, 36, 48 ...

//6, 12의 최소 공배수  → 12

//2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단, a>b)
//a와 b의 최대공약수는 b와 r의 최대공약수와 같다.
//이 성질에 따라, b를 r로 나눈 나머지 r'를 구하고,
//다시 r을 r'로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수다.
//"A > B 일때 A와 B의 최대공약수는 B와 나머지 R의 최대공약수와 같다."

//1. 큰 수(A)를 작은 수(B)로 나눈다. ( A > B )
//2. 나누는 수(B)를 나머지(R)로 계속 나눈다.
//3. 나머지가 0이 나오면 나누는 수가 최대 공약수

//최소공배수는 두 수를 곱한 후에 최대공약수로 나누면 나온다.

//다른 사람의 풀이
function solution(n, m) {
    const numbers = [n, m];
    numbers.sort((a, b) => a - b);
    const [min, max] = numbers;

    let arr = [];
    for (let i = 1; i <= min; i++) {
        if (min % i === 0 && max % i === 0) {
        arr.push(i);
        }
    }

    const GCD = Math.max(...arr);
    const LCM = (min * max) / GCD;

    return [GCD, LCM];
}

//두 정수 n, m을 배열로 받은 다음, 작은 수와 큰 수를 구분하기 위해서 오름차순으로 정렬을 했다.
//최대공약수는 1부터 시작해서 두 정수를 나눈 나머지가 0인 값을 배열에 추가한 다음, 배열에서 가장 큰 값을 반환한다.
