//나의 풀이
function solution(arr) {
    var answer = [];
    arr.sort((a, b) => b-a);
    if(arr.length <= 1){
        return [-1];
    }else {
        for(let i=0; i<arr.length-1; i++){
           answer.push(arr[i]);
        }    
    }
    return answer;
}

//보자마자 sort를 이용해서 내림차순으로 바꾼 후 마지막 배열만 빼고 push 해주면 되겠다 생각했다.
//그리고 첫 조건으로는 배열의 길이가 0이거나 1과 같을 때는 [-1]을 리턴 .. 
//생각보다 간단하네 하고 코드 진행을 돌렸는데 전부 통과 !
//하지만 제출을 하니까 온통 실패 투성이로 가득 찬 빨간 불 ...
//코딩 테스트 풀면서 처음 받았다 ....
//배열의 순서 자체가 의미있는 데이터일 수 있기 때문에 섣불리 sorting을 하는 습관을 가지면 안된다라는 조언을 얻고 다음 풀이방식을 작성하였다.

/*
테스트 1
입력값 〉	[4, 3, 2, 1]
기댓값 〉	[4, 3, 2]
실행 결과 〉	테스트를 통과하였습니다.
테스트 2
입력값 〉	[10]
기댓값 〉	[-1]
실행 결과 〉	테스트를 통과하였습니다.
테스트 결과 (~˘▾˘)~
2개 중 2개 성공

테스트 1 〉	실패 (16.80ms, 43.2MB)
테스트 2 〉	실패 (0.25ms, 33.6MB)
테스트 3 〉	실패 (0.34ms, 33.8MB)
테스트 4 〉	실패 (0.22ms, 33.6MB)
테스트 5 〉	실패 (0.17ms, 33.6MB)
테스트 6 〉	실패 (0.55ms, 33.6MB)
테스트 7 〉	실패 (0.50ms, 33.7MB)
테스트 8 〉	실패 (0.06ms, 33.4MB)
테스트 9 〉	실패 (0.15ms, 33.5MB)
테스트 10 〉	실패 (0.05ms, 33.6MB)
테스트 11 〉	실패 (0.22ms, 33.5MB)
테스트 12 〉	실패 (0.15ms, 33.5MB)
테스트 13 〉	실패 (0.16ms, 33.5MB)
테스트 14 〉	실패 (0.37ms, 33.4MB)
테스트 15 〉	실패 (0.22ms, 33.6MB)
테스트 16 〉	실패 (0.41ms, 33.7MB)
*/

function solution(arr) {
    var answer = [];

    if(arr.length <= 1){
        return [-1];
    }else {
        let min = Math.min(arr);
        let idx = arr.indexOf(min);
        arr.splice(idx, 1);
        return answer = arr;
    }
}

//그렇게 다시 푼 두번째 방법이다.
//배열이 비어있을때와 그렇지 않을때 조건문을 만든다.
//비어있을때는 [-1]을 return하고 그렇지 않을때는 제일 작은 수를 뺀 나머지 배열을 return해준다.
//제일 작은수를 Math.min으로 구해주고 그숫자의 index값을 indexOf()로 구해서 배열에 splice()메소드로 뺀후 반환한다.
//그런데, 또 실패를 받았다 ... 이번에는 틀릴 수 없겠구나 했는데 ..

/*
테스트 1
입력값 〉	[4, 3, 2, 1]
기댓값 〉	[4, 3, 2]
실행 결과 〉	테스트를 통과하였습니다.
테스트 2
입력값 〉	[10]
기댓값 〉	[-1]
실행 결과 〉	테스트를 통과하였습니다.
테스트 결과 (~˘▾˘)~
2개 중 2개 성공

테스트 1 〉	실패 (7.66ms, 44.4MB)
테스트 2 〉	실패 (0.08ms, 33.6MB)
테스트 3 〉	실패 (0.12ms, 33.6MB)
테스트 4 〉	실패 (0.07ms, 33.5MB)
테스트 5 〉	실패 (0.05ms, 33.5MB)
테스트 6 〉	실패 (0.10ms, 33.6MB)
테스트 7 〉	실패 (0.12ms, 33.7MB)
테스트 8 〉	실패 (0.04ms, 33.4MB)
테스트 9 〉	실패 (0.05ms, 33.5MB)
테스트 10 〉	실패 (0.04ms, 33.5MB)
테스트 11 〉	실패 (0.04ms, 33.5MB)
테스트 12 〉	실패 (0.04ms, 33.5MB)
테스트 13 〉	실패 (0.06ms, 33.6MB)
테스트 14 〉	실패 (0.10ms, 33.6MB)
테스트 15 〉	실패 (0.07ms, 33.6MB)
테스트 16 〉	실패 (0.11ms, 33.7MB)
*/

function solution(arr) {
    var answer = [];

    if(arr.length <= 1){
        return [-1];
    }else {
        let min = Math.min(...arr);
        let idx = arr.indexOf(min);
        arr.splice(idx, 1);
        return answer = arr;
    }
}

//다시 차근차근 코드를 보니 arr을 스프레드로 적지 않고 정수를 저장한 배열 arr 그대로 넣어주었더라
//스프레드로 바꾸니 성공 ... !!!!!!!

/*
테스트 1 〉	통과 (0.53ms, 43.3MB)
테스트 2 〉	통과 (0.04ms, 33.6MB)
테스트 3 〉	통과 (0.05ms, 33.7MB)
테스트 4 〉	통과 (0.04ms, 33.6MB)
테스트 5 〉	통과 (0.04ms, 33.6MB)
테스트 6 〉	통과 (0.05ms, 33.7MB)
테스트 7 〉	통과 (0.07ms, 33.6MB)
테스트 8 〉	통과 (0.04ms, 33.6MB)
테스트 9 〉	통과 (0.04ms, 33.5MB)
테스트 10 〉	통과 (0.08ms, 33.5MB)
테스트 11 〉	통과 (0.06ms, 33.7MB)
테스트 12 〉	통과 (0.04ms, 33.5MB)
테스트 13 〉	통과 (0.04ms, 33.5MB)
테스트 14 〉	통과 (0.05ms, 33.6MB)
테스트 15 〉	통과 (0.04ms, 33.6MB)
테스트 16 〉	통과 (0.05ms, 33.6MB)
*/


