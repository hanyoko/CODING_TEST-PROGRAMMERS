//나의 풀이
function solution(A, B){
    var answer = [];
    var a = A.sort((a,b) => a-b); // 오름차순 정렬
    var b = B.sort((a,b) => b-a); // 내림차순 정렬
    for(var i=0; i<a.length; i++){
      answer.push(a[i] * b[i]);
    }
    
    var result = answer.reduce((a, b) => a+b);
    return result;
  }

//두 배열의 각 원소를 뽑아 곱한 값의 최종 합이 최소가 되려면 가장 작은 수와 가장 큰수를 곱하고 그 다음 작은 수와 그 다음 큰 수를 곱하고 ... 이렇게 곱해 나간 값을 다 더한 값이 가장 작은 최종 합이 된다.
//1-1. [1,4,2]와 [5,4,4] 가 있다면
//1-2. (가장 작은 수)1 * (가장 큰 수)4 + (그 다음 작은 수)2 * (그 다음 큰 수)4 + (그 다음 작은 수)4 * (그 다음 큰 수)5 = 29
//1-3. 이 값이 최솟값이 된다.
//따라서, 배열 A는 작은수 ~ 큰수로 정렬되도록 오름차순 정렬을 해준다.
//배열 B는 큰수~ 작은수로 정렬되도록 내림차순 정렬을 해준다.
//인덱스가 같은 A와 B의 원소들을 곱한다.
//곱한 값을 모두 더해준다.

//처음 문제를 봤을 땐 약간 어렵게 생각했다.
//완전탐색을 해야 하는 문제인가? 아니면 저번에 살짝 맛봤던 동적 알고리즘으로 풀어야 하는 건가? 생각했다.
//하지만 그렇게 까지 복잡하게 풀 문제는 아니었다 ㅎㅎ .. 어릴 때 코딩을 배웠으면 더 잘했을지도 모르겠단 생각이..
//문제를 보자마자 어렵게만 생각하는 습관(?)을 고쳐야 할 필요가 있는 것 같다.

//다른 풀이
function solution(A, B) {
    A.sort((a, b) => a - b);
    B.sort((a, b) => b - a);
    return A.reduce((sum, curr, i) => sum + curr * B[i], 0);
  }

//제출하고 나서 조금 더 깔끔하게 풀 수 있는 방법이 없을까 고민해보았다..

//각 배열의 원소를 곱해서 더했을 때 최솟값을 만들기 위해서는 (가장 작은 수 * 가장 큰 수)를 곱한 수를 더하면 된다.
//여기에서 아이디어를 얻어서 첫 번째 배열은 오름차순으로 정렬하고, 두 번째 배열은 내림차순으로 정렬했다.
//그리고 두 배열의 인덱스를 0번부터 순서대로 곱해서 더해나간다.