//나의 풀이
function solution(num_list, n) {
    var answer = [];
    for(let i=0; i<num_list.length; i+=n){
        answer.push(num_list[i]);
    }
    return answer;
}

//우선 문제를 보고 배열의 인덱스를 이용해서 풀어야겠다고 생각했다.
//인덱스는 n의 값을 기준으로 특정한 간격을 유지하는데, 이것을 이용하는 방법은 크게 2가지인것 같다.
//만약 n=2이면 1️.인덱스의 n을 2씩 더하는방법과 2.인덱스를 2로 나눠서 0이 되는지를 확인하는 방법이다.
//나는 인덱스를 n씩 더하는 방법을 이용해서 문제를 풀었다.
//일단 빈배열 list를 선언하고, for문을 통해서 인덱스의 범위를 지정하였다.
//여기까지는 평소에 for문을 돌리는 방법과 같지만 i++과 같이 i를 1씩 더하는 방법이 아닌,
//i +=n 을 통해서 for문을 한번 돌때마다 n씩을 더해주게 했다.
//for문의 안에서는 push()를 통해서 배열의 i번째 값들을 list에 추가시켰다.
//for문을 다 돈 다음에는 for문을 빠져나와서 list를 return한다.

//다른 사람의 풀이
function solution(num_list, n) {
    return num_list.filter((_, index) => index % n === 0);
}

//이 코드의 인덱스를 2로 나눠서 0이 되는지를 확인하는 방법을 사용했다.
//그러면서 for문 대신 filter를 이용해서 필요한 값만을 뽑아냈다.
//filter()의 인덱스만을 이용해도 되기 때문에, 첫번째 인자로  _ (언더스코어)를 사용했다.
//해당 매개변수를 사용하지 않을때는 언더스코어를 사용한다는 것을 처음봐서 공부하였다. 
//index를 n으로 나눠서 그 값이 0인것만 filter를 통해서 남기고 바로 리턴한다. 

//위의 코드를 조금 더 간단하게 나타낸 코드도 있었다.
const solution = (num_list, n) => num_list.filter((_, i) => !(i % n))

//% 나머지 연산자를 사용하여 n으로 나눈 값이 나머지가 있다면 (=n으로나눈 나머지가 0이 아니라면)
//!연산자를 통해서 걸러준다. 그러면 n으로 나눈 나머지가 0인 값만 남을 것이다.